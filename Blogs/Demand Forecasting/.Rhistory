}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
train_predict
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecasts))/((abs(outsample)+abs(forecasts))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecasts=train_predict$forecast)
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecasts))/((abs(outsample)+abs(forecasts))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
train_predict
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecasts=train_predict$forecast)
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecasts))/((abs(outsample)+abs(forecasts))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecasts=train_predict$forecast)
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecasts))/((abs(outsample)+abs(forecasts))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecast=train_predict$forecast)
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecasts))/((abs(outsample)+abs(forecast))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecast=train_predict$forecast)
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecast))/((abs(outsample)+abs(forecast))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecast=train_predict$forecast)
SMAPE<-mean(SMAPE_ERR,na.rm = T)
sprintf("The value of SMAPE for Store-1 & Item-1 is %f ", SMAPE )
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecast))/((abs(outsample)+abs(forecast))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecast=train_predict$forecast)
SMAPE<-mean(SMAPE_ERR,na.rm = T)
sprintf("The value of SMAPE for Store-1 & Item-1 is %f ", SMAPE )
train$Year = NULL
train$Month = NULL
head(train)
train$Year = NULL
train$Month = NULL
train$sales = log1p(train$sales)
head(train)
train$Year = NULL
train$Month = NULL
train$sales = log1p(train$sales)
colnames(train) = c("ds", "store", "item","y")
train_splitting = split(train, by = c("store", "item"), keep.by = FALSE)
train$Year = NULL
train$Month = NULL
train$sales = log1p(train$sales)
train$Year = NULL
train$Month = NULL
train$sales = log1p(train$sales)
#train$Year = NULL
#train$Month = NULL
train$sales = log1p(train$sales)
#train$Year = NULL
#train$Month = NULL
#train$sales = log1p(train$sales)
colnames(train) = c("ds", "store", "item","y")
train_splitting = split(train, by = c('store', 'item'), keep.by = FALSE)
train$Year=NULL
train$Month=NULL
head(train)
train$sales=log1p(train$sales)
#train$Year=NULL
#train$Month=NULL
#head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
train_splitting= split(train, by=c('store', 'item'), keep.by=FALSE)
#train$Year=NULL
#train$Month=NULL
#head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
train_splitting= split(train, by=c('store', 'item'), keep.by=FALSE)
#train$Year=NULL
#train$Month=NULL
#head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
split(train)
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecast))/((abs(outsample)+abs(forecast))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecast=train_predict$forecast)
SMAPE<-mean(SMAPE_ERR,na.rm = T)
sprintf("The value of SMAPE for Store-1 & Item-1 is %f ", SMAPE )
train$Year=NULL
train$Month=NULL
head(train)
train$sales=log1p(train$sales)
train$Year=NULL
train$Month=NULL
head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
train_splitting= split(train, by=c('store', 'item'), keep.by=FALSE)
split(train, by=c("store", "item"), keep.by=FALSE)
train$Year=NULL
train$Month=NULL
head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
train_splitting= split(train, c('store', 'item'), keep.by=FALSE)
train$Year=NULL
train$Month=NULL
head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
train_splitting= split(train, c('store', 'item'))
class(train_splitting)
train$Year=NULL
train$Month=NULL
head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
train_splitting= split(train, c('store', 'item'))
class(train_splitting)
prediction<-function(df){
playoffs <- data_frame(
holiday = 'playoff',
ds = as.Date(c('2013-07-12', '2014-07-12', '2014-07-19',
'2014-07-02', '2015-07-11', '2016-07-17',
'2016-07-24', '2016-07-07','2016-07-24')),
lower_window = 0,
upper_window = 1)
#######  I have inlcuded the Holiday Sales fofr Festive seasons like New Year & Christmas for different Years in Superbowls.
superbowls <- data_frame(
holiday = 'superbowl',
ds = as.Date(c('2013-01-01', '2013-12-25', '2014-01-01', '2014-12-25','2015-01-01', '2015-12-25','2016-01-01', '2016-12-25',
'2017-01-01', '2017-12-25')),
lower_window = 0,
upper_window = 1)
holidays <- bind_rows(playoffs, superbowls)
model_prophet <- prophet()
model_prophet <- add_seasonality(model_prophet, name='daily', period=60, fourier.order=5)
model_prophet <- prophet(df, holidays = holidays,holidays.prior.scale = 0.5, yearly.seasonality = 4,
interval.width = 0.95,changepoint.prior.scale = 0.006,daily.seasonality = T)
future = make_future_dataframe(model_prophet, periods = 90)
forecast = predict(model_prophet, future)
forecast_final<-  xts::last(forecast[, c("ds","yhat")],90)
return(forecast_final)
}
prediction_final=as.data.frame(sapply(train_splitting[c(1,2)],prediction))
knitr::opts_chunk$set(echo = TRUE)
# We will predict for 90 days sales starting from 01-JAN-2018.
h <- 90
tt <-  cbind(c(1:(length(y) + h), rep(0.2*h)))
knitr::opts_chunk$set(echo = TRUE)
rm(list=ls())
pacman::p_load(
timeSeries,
doBy,
formattable,
wesanderson,
forecast,
prophet,
nnfor
)
suppressMessages(library(data.table))
suppressMessages(library(DT))
suppressMessages(library(tidyverse))
suppressMessages(library(reshape))
suppressMessages(library(stringr))
suppressMessages(library(formattable))
suppressMessages(library(gridExtra))
suppressMessages(library(ggplot2))
suppressMessages(library(plotly))
suppressMessages(library(corrplot))
suppressMessages(library(wesanderson))
suppressMessages(library(RColorBrewer))
suppressMessages(library(gridExtra))
suppressMessages(library(zoo))
suppressMessages(library(forecast))
suppressMessages(library(prophet)) ### For Prophet Forecasting
suppressMessages(library(nnfor))    ### For Neural Network Forecasting
set.seed(2018)
train <- read.csv('./data/train.csv')
test <- read.csv('./data/test.csv')
str(train)
summary(train)
str(test)
# Take look at the data distribution
skimr::skim(train)
head(train, 5)
#Extraction of year and month of year
train$Year <- year(train$date)
train$Month <- as.yearmon(train$date)
head(train,5)
colSums(is.na(train))
# Function 1 : For ploting missing value
plot_missing <- function(data, title = NULL, ggtheme = theme_gray(), theme_config = list("legend.position" = c("bottom"))) {
## Declare variable first to pass R CMD check
feature <- num_missing <- pct_missing <- group <- NULL
## Check if input is data.table
is_data_table <- is.data.table(data)
## Detect input data class
data_class <- class(data)
## Set data to data.table
if (!is_data_table) data <- data.table(data)
## Extract missing value distribution
missing_value <- data.table(
"feature" = names(data),
"num_missing" = sapply(data, function(x) {sum(is.na(x))})
)
missing_value[, feature := factor(feature, levels = feature[order(-rank(num_missing))])]
missing_value[, pct_missing := num_missing / nrow(data)]
missing_value[pct_missing < 0.05, group := "Good"]
missing_value[pct_missing >= 0.05 & pct_missing < 0.4, group := "OK"]
missing_value[pct_missing >= 0.4 & pct_missing < 0.8, group := "Bad"]
missing_value[pct_missing >= 0.8, group := "Remove"][]
## Set data class back to original
if (!is_data_table) class(missing_value) <- data_class
## Create ggplot object
output <- ggplot(missing_value, aes_string(x = "feature", y = "num_missing", fill = "group")) +
geom_bar(stat = "identity") +
geom_text(aes(label = paste0(round(100 * pct_missing, 2), "%"))) +
scale_fill_manual("Group", values = c("Good" = "#1a9641", "OK" = "#a6d96a", "Bad" = "#fdae61", "Remove" = "#d7191c"), breaks = c("Good", "OK", "Bad", "Remove")) +
scale_y_continuous(labels = comma) +
coord_flip() +
xlab("Features") + ylab("Number of missing rows") +
ggtitle(title) +
ggtheme + theme_linedraw()+
do.call(theme, theme_config)
## Print plot
print(output)
## Set return object
return(invisible(missing_value))
}
plot_missing(train)
gbp1<-wes_palette("GrandBudapest2")[1]
plot_sales_dist <- ggplot(data = train, aes(x = sales)) +
geom_histogram(fill = "#a6d96a", alpha = 0.9) +
labs(x = NULL, y = NULL, title = "Distribution of Sales Prices") +
theme_minimal() + theme(plot.title = element_text(vjust = 3, size = 15 ))
plot_sales_dist
MSP <- aggregate(sales ~ date, train, mean)
growth_sales_overtime <-ggplot(MSP, aes(x=as.factor(date), y=sales))+
geom_line(color='black', aes(group=1), size=.5)+
geom_point(colour='red', size = 1.5, alpha=0.5)+
labs(title="The Growth of Sale Prices by date", x=NULL, y="Sale Price")+
theme( plot.title=element_text(vjust=3, size=15) ) + theme_minimal()
growth_sales_overtime
MSP$rate = c(0, 100*diff(MSP$sales)/MSP[-nrow(MSP),]$sales)
sales_price_change <-ggplot(MSP, aes(x=as.factor(date), y=rate))+
geom_line(color= "black", aes(group=1), size=1)+
#geom_point(colour=gbp1, size = 3.5, alpha=0.5)+
labs(title="Change rate of Sale Price", x="date", y="rate of change")+
geom_hline(yintercept = 0, color = 'red' )+
theme(plot.title=element_text(size=15))+ theme_minimal()
sales_price_change
MSP <- aggregate(sales ~ Month, train, mean)
sales_price_month <- ggplot(data = MSP, aes(Month, y = sales)) +
geom_line(color = "black", aes(group=1), size = 0.5) +
geom_point(color = "red", size = 0.5) +
labs(title = "The Growth of Sales Price by Month of Year", x = NULL, y = "Sales Price") +
theme(plot.title = element_text(vjust=3, size = 15)) +
theme_minimal()
sales_price_month
MSP$rate = c(0, 100*diff(MSP$sales)/MSP[-nrow(MSP),]$sales)
sales_change_month <-ggplot(MSP, aes(x=Month, y=rate))+
geom_line(color= "black", aes(group=1), size=0.5) +
geom_point(color = "red", aes(group=1), size=1)
labs(title="Change rate of Sale Price", x="Month", y="rate of change")+
geom_hline(yintercept = 0, color = "blue" ) +
theme(plot.title=element_text(size=15))+ theme_minimal()
sales_change_month
MSP <- aggregate(sales ~ Year, train, mean)
sales_price_year <- ggplot(data = MSP, aes(Year, y = sales)) +
geom_line(color = "black", aes(group=1), size = 0.5) +
geom_point(color = "red", size = 1) +
labs(title = "The Growth of Sales Price by Year", x = NULL, y = "Sales Price") +
theme(plot.title = element_text(vjust=3, size = 15)) +
theme_minimal()
sales_price_year
MSP$rate = c(0, 100*diff(MSP$sales)/MSP[-nrow(MSP),]$sales)
sales_change_year <-ggplot(MSP, aes(x=as.factor(Year), y=rate))+
geom_line(color= "black", aes(group=1), size=0.5)+
geom_point(colour= "red", size = 3.5, alpha= 1)+
labs(title="Change rate of Sale Price", x="Year", y="rate of change")+
geom_hline(yintercept = 0, color = gbp1 )+
theme(plot.title=element_text(size=15))+ theme_minimal()
sales_change_year
yearly_store_data <- aggregate(sales ~ store + Year, train, mean)
plot_store_data <- ggplot(data = yearly_store_data, aes(group = store)) +
geom_line(aes(x = Year, y = sales, color = store)) +
geom_text(data = subset(yearly_store_data, Year == '2017'), aes(label = store, colour = store , x = Year, y = sales), hjust = -.1) +
theme(plot.margin = unit(c(1,3,1,1), "lines"))
plot_store_data
yearly_item_data <- aggregate(sales ~ item + Year, train, mean)
plot_yearly_item <- ggplot(data = yearly_item_data) +
geom_line(aes(x = Year, y = sales, group = item,  colour = item)) +
geom_text(data = subset(yearly_item_data, Year == '2017'), aes(label = item, colour = item , x = Year, y = sales), hjust = -.1) +
theme(plot.margin = unit(c(1,3,1,1), "lines"))
plot_yearly_item
#get the store and item variables only
store1_item1 <- subset(train, train$store == 1 & train$item == 1)
#put it in a dataframe and get the sum of all items
stats = data.frame(y = log1p(store1_item1$sales), ds = store1_item1$date)
# get the sum of all the log of sales with respect to date
stats = aggregate(stats$y, by=list(stats$ds), FUN = sum)
colnames(stats) <- c("ds", "y")
#build prophetmodel
prophet_model = prophet(stats)
summary(prophet_model)
future <-  make_future_dataframe(prophet_model, periods = 90)
forecast = predict(prophet_model, future)
forecast
add_changepoints_to_plot <-  function(model, threshold = 0.01, cp_color = "red", cp_linetype = "dashed", trend = TRUE) {
layers <- list()
if (trend){
trend_layer <-  ggplot2::geom_line(
ggplot2::aes_string("ds", "trend"), color = cp_color
)
layers <- append(layers, trend_layer)
}
signif_changepoints <- model$changepoints[abs(model$params$delta) >= threshold]
cp_layer <- ggplot2::geom_vline(
xintercept = as.integer(signif_changepoints), color = cp_color,
linetype = cp_linetype)
layers <- append(layers, cp_layer)
return(layers)
}
plot(prophet_model, forecast) + add_changepoints_to_plot(prophet_model)
prophet_plot_components(prophet_model, forecast)
playoffs <-  data_frame(
holiday = 'playoff',
ds = as.Date(c('2013-07-12', '2014-07-12', '2014-07-19','2014-07-02', '2015-07-11', '2016-07-17',
'2016-07-24', '2016-07-07','2016-07-24')),
lower_window = 0,
upper_window = 1
)
playoffs
superbowls <- data_frame(
holiday = "superbowls",
ds = as.Date(c('2013-01-01', '2013-12-25', '2014-01-01', '2014-12-25','2015-01-01', '2015-12-25','2016-01-01', '2016-12-25','2017-01-01', '2017-12-25')),
lower_window = 0,
upper_window = 1
)
superbowls
holidays <-  bind_rows(playoffs, superbowls)
holidays
nfl_sunday <-  function(ds){
dates <- as.Date(ds)
month <- as.numeric(format(dates, '%m'))
as.numeric((weekdays(dates) == "Sundays") & (month > 8 | month < 2))
}
stats$nfl_sunday <- nfl_sunday(stats$ds)
model_prophet <- prophet()
model_prophet <- add_regressor(model_prophet, 'nfl_sunday')
model_prophet <- add_seasonality(model_prophet, name='daily', period=60, fourier.order=5)
model_prophet <- prophet(stats, holidays = holidays,holidays.prior.scale = 0.5, yearly.seasonality = 4,
interval.width = 0.95,changepoint.prior.scale = 0.006,daily.seasonality = T)
future = make_future_dataframe(model_prophet, periods = 90, freq = 'days')
forecast = predict(model_prophet, future)
plot(model_prophet, forecast) + add_changepoints_to_plot(model_prophet)
prophet_plot_components(model_prophet, forecast)
predict_store1_item1=data.frame(date=forecast$ds,forecast=expm1(forecast$yhat))
predict_store1_item1$yearmonth=as.yearmon(predict_store1_item1$date)
colnames(predict_store1_item1)<-c("ds","forecast","yearmonth")
smape_cal <- function(outsample, forecast){
outsample <- as.numeric(outsample)
forecast <- as.numeric(forecast)
smape <- (abs(outsample-forecast))/((abs(outsample)+abs(forecast))/2)
return(smape)
}
str(stats)
stats$ds=as.Date(stats$ds)
predict_store1_item1$ds=as.Date(predict_store1_item1$ds)
train_predict=merge(stats,predict_store1_item1,by="ds",all.x=T)
SMAPE_ERR <- smape_cal(outsample=train_predict$y, forecast=train_predict$forecast)
SMAPE<-mean(SMAPE_ERR,na.rm = T)
sprintf("The value of SMAPE for Store-1 & Item-1 is %f ", SMAPE )
train$Year=NULL
train$Month=NULL
head(train)
#train$sales=log1p(train$sales)
#colnames(train)<- c("ds","store","item","y")
train_splitting= split(train, c('store', 'item'))
class(train_splitting)
prediction<-function(df){
playoffs <- data_frame(
holiday = 'playoff',
ds = as.Date(c('2013-07-12', '2014-07-12', '2014-07-19',
'2014-07-02', '2015-07-11', '2016-07-17',
'2016-07-24', '2016-07-07','2016-07-24')),
lower_window = 0,
upper_window = 1)
#######  I have inlcuded the Holiday Sales fofr Festive seasons like New Year & Christmas for different Years in Superbowls.
superbowls <- data_frame(
holiday = 'superbowl',
ds = as.Date(c('2013-01-01', '2013-12-25', '2014-01-01', '2014-12-25','2015-01-01', '2015-12-25','2016-01-01', '2016-12-25',
'2017-01-01', '2017-12-25')),
lower_window = 0,
upper_window = 1)
holidays <- bind_rows(playoffs, superbowls)
model_prophet <- prophet()
model_prophet <- add_seasonality(model_prophet, name='daily', period=60, fourier.order=5)
model_prophet <- prophet(df, holidays = holidays,holidays.prior.scale = 0.5, yearly.seasonality = 4,
interval.width = 0.95,changepoint.prior.scale = 0.006,daily.seasonality = T)
future = make_future_dataframe(model_prophet, periods = 90)
forecast = predict(model_prophet, future)
forecast_final<-  xts::last(forecast[, c("ds","yhat")],90)
return(forecast_final)
}
#prediction_final=as.data.frame(sapply(train_splitting[c(1,2)],prediction))
y <- ts(stats$y, frequency=365, start=2013, end=2017)
head(y)
plot(y)
# We will predict for 90 days sales starting from 01-JAN-2018.
h <- 90
tt <-  cbind(c(1:(length(y) + h), rep(0.2*h)))
#Observe that the deterministic trend ends with zeros
# We will predict for 90 days sales starting from 01-JAN-2018.
h <- 90
tt <-  cbind(c(1:(length(y) + h), rep(0.2*h)))
#Observe that the deterministic trend ends with zeros
print(tt)
# We will predict for 90 days sales starting from 01-JAN-2018.
h <- 90
tt <-  cbind(c(1:(length(y) + h), rep(0.2*h)))
#Observe that the deterministic trend ends with zeros
#print(tt)
# We will predict for 90 days sales starting from 01-JAN-2018.
h <- 90
tt <-  cbind(c(1:(length(y) + h), rep(0.2*h)))
#Observe that the deterministic trend ends with zeros
#print(tt)
# Fit a network with no differencing, no univariate lags, and fixed deterministic trend
fit1 <- mlp(y,difforder=0,lags=0,xreg=tt,xreg.lags=list(0),xreg.keep=TRUE)
print(fit1)
plot(fit1)
plot(forecast(fit1, h=h, xreg=tt))
plot(forecast(fit1, h=h, xreg=tt))
print("The MSE for Store-1 & Item -1 is")
print(round(fit1$MSE,4))
fit1
tt
tt2 <- tt[-(1:h),, drop = FALSE]
plot(forecast(fit1, h=h, xreg=tt2))
tt2 <- tt[-(1:h),,drop=FALSE]
plot(forecast(fit1,h=h,xreg=tt2))
tt2 <- tt[-(1:h),,drop=FALSE]
tt2
tt2 <- tt[-(1:h),,drop=FALSE]
plot(forecast(fit1,h=h,xreg=tt2))
tt2 <- tt[-(1:h),drop=FALSE]
plot(forecast(fit1,h=h,xreg=tt2))
fit2 <- mlp(y,difforder=0,lags=0,xreg=tt2,xreg.lags=list(0),xreg.keep=TRUE,outplot=1)
fit2 <- mlp(y,difforder=0,lags=0,xreg=tt2,xreg.lags=list(0),xreg.keep=TRUE,outplot=1)
